function activate_conda() {
    local current_dir_name=$(basename "$PWD")
    local is_env=$(awk -F/ -v name="$current_dir_name" '$NF == name {print $NF}' ~/.conda/environments.txt )

    if [[ ! -z $is_env ]]; then
        # # Lazy-load conda
        # if [ -d "$HOME/anaconda3" ]; then
        #   _conda_loaded=0
        #   _load_conda() {
        #     if (( _conda_loaded == 0 )); then
        #       if [ -f "$HOME/anaconda3/etc/profile.d/conda.sh" ]; then
        #         source "$HOME/anaconda3/etc/profile.d/conda.sh" &> /dev/null
        #       else
        #         export PATH="$HOME/anaconda3/bin:$PATH"
        #       fi
        #       _conda_loaded=1
        #     fi
        #   }
        #   function conda() { _load_conda; command conda "$@"; }
        #   # If you want automatic environment activation in certain directories, keep your activate_conda(); it can call conda after _load_conda.
        # fi
        source "/home/$USER/anaconda3/etc/profile.d/conda.sh" &> /dev/null
        conda activate $current_dir_name &> /dev/null
    # else
    #     conda activate $CONDA_DEFAULT_ENV
    fi


}

function config_opener(){
    local config_path=$1
    local program=$2
    local session_name=$2
    (alacritty -e zsh -c "tmux new-session -s '${session_name}' -c ${config_path} '${program}'" &) &>/dev/null
}

function nconfig(){
    config_opener "~/.config/nvim" "nvim" "nvim-config"
}

function note(){
    config_opener "~/notes/" "nvim" "note"
}

function tls() {
    active_session="$(tmux list-sessions 2>/dev/null)"
    if [[ ${#active_session} -ne 0 ]]; then
        echo "$active_session"
    else
        echo "No Session !!!"
    fi
}

function quick_tmux_call() {
    if [[ $# -eq 0 || $1 == "--help" || $1 == "-h" ]]; then
        echo "-h, --help : Display this help message."
        echo "\$1 : Name of the tmux session."
        echo "\$2 : Path to the directory for the session."
        echo "\$3 : Optional program to start in the session."
    else
        local session_name="$1"
        local dir_path="$2"
        local program="${3:-}"
        # Validate session name and directory path
        if [[ -z "$session_name" || -z "$dir_path" ]]; then
            echo "Error: Both session name and directory path are required."
            return 1
        fi
        # Check if session already exists
        if tmux has-session -t "$session_name" 2>/dev/null; then
            echo "Attaching to existing session '$session_name'."
            # Attach to the session
            tmux attach-session -t "$session_name"
        else
            # Create a new session in detached mode
            tmux -u new -s "$session_name" -c "$dir_path" "$program -c 'cd $dir_path'"
       fi
    fi
}

function keymap(){
    value=$(bindkey | fzf --ansi --reverse --preview="echo {} | awk '{print \$2}' ")
    if [ ! -z $value ]; then
        echo $value | awk '{print $2}' | xclip -selection clipboard
    fi
}

function yy() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$tmp"
    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
        cd -- "$cwd"
    fi
    rm -f -- "$tmp"
}

function compile() {
    local file_name="$1"
    if [[ -z "$file_name" ]]; then
        echo "Usage: compile <file> [extra flags...]"
        return 2
    fi

    local output="${file_name%.*}"
    local file_type="${file_name##*.}"
    local objfile="${output}.o"
    shift

    # New: trace flag and helper
    local TRACE=0
    run() {
        # print the command in a nice way when TRACE=1
        if (( TRACE )); then
            # show the command like a shell would
            printf '+ %s\n' "$(printf "%q " "$@")"
        fi
        "$@"
    }

    case "$file_type" in
        c|cpp|cc|cxx)
            run gcc -g -Wall "$file_name" -o "$output" -lm "$@" || return $?
            ;;
        asm|s)
            local entry="" nasm_format="" ld_format="" keep_obj=0 use_gcc=0 gcc_format_flag="" no_pie="" ld_args=()

            while (($#)); do
                case "$1" in
                    -e|--entry)
                        if [[ -n "$2" ]]; then entry="$2"; shift 2; else echo "Error: $1 needs an argument" >&2; return 3; fi
                        ;;
                    -f|--format)
                        if [[ -n "$2" ]]; then nasm_format="$2"; shift 2; else echo "Error: $1 needs an argument" >&2; return 3; fi
                        ;;
                    --keep-obj) keep_obj=1; shift ;;
                    --gcc) use_gcc=1; shift ;;
                    -no-pie|--no-pie) no_pie="$1"; shift ;;
                    -v|--verbose) TRACE=1; shift ;;
                    --) shift; while (($#)); do ld_args+=("$1"); shift; done ;;
                    *) ld_args+=("$1"); shift ;;
                esac
            done

            case "$nasm_format" in
                elf32) ld_format="elf_i386"; gcc_format_flag="-m32" ;;
                elf64) ld_format="elf_x86_64"; gcc_format_flag="-m64" ;;
                macho32) ld_format="macho_i386"; gcc_format_flag="-m32" ;;
                macho64) ld_format="macho_x86_64"; gcc_format_flag="-m64" ;;
                *) ld_format=""; gcc_format_flag="-m64" ;;
            esac

            # assemble (use run to show command when TRACE=1)
            if [[ -n "$nasm_format" ]]; then
                run nasm -f "$nasm_format" -o "${objfile}" "$file_name" || return $?
            else
                run nasm -f elf64 -o "$objfile" "$file_name" || return $?
            fi

            # link
            if [[ -n "$ld_format" && $use_gcc -eq 0 ]]; then
                if [[ -n "$entry" ]]; then
                    run ld "$objfile" -o "${output}" -e "$entry" -m "$ld_format" "${ld_args[@]}" || return $?
                else
                    run ld "$objfile" -o "${output}" -m "$ld_format" "${ld_args[@]}" || return $?
                fi
            elif [[ $use_gcc -eq 1 ]]; then
                local cmd=(gcc "$objfile" -o "${output}")
                if [[ -n "$entry" ]]; then cmd+=(-Wl,--entry="$entry"); fi
                if [[ -n "$no_pie" ]]; then cmd+=("$no_pie"); fi
                if [[ -n "$gcc_format_flag" ]]; then cmd+=("$gcc_format_flag"); fi
                if ((${#ld_args[@]})); then cmd+=("${ld_args[@]}"); fi
                run "${cmd[@]}" || return $?
            else
                if [[ -n "$entry" ]]; then
                    run ld "$objfile" -o "${output}" -e "$entry" "${ld_args[@]}" || return $?
                else
                    run ld "$objfile" -o "${output}" "${ld_args[@]}" || return $?
                fi
            fi

            if [[ $keep_obj -eq 0 ]]; then
                rm -f "${objfile}"
            fi
            ;;
        *)
            echo "Unsupported file type: $file_type" >&2
            return 1
            ;;
    esac

    return 0
}

function tt(){
    local wordlist=$1
    local num=$2
    if [[ "$num" =~ ^[0-9]+ ]]; then
        if [[ "$wordlist" =~ ^[0-9]+ ]]; then
            toipe -w top${wordlist} -n ${num}
        elif [[ "$wordlist" == "cms" ]]; then
            toipe -w commonly-misspelled -n ${num}
        else
            toipe -w ${wordlist} -n ${num}
        fi
    else
        echo "Invalid 2nd parameter."
    fi
}

function mirror() {
    case "$1" in
        on)
            echo 'Turning Mirror on...'
            hyprctl keyword monitor "eDP-1, 1920x1080@30, auto, 1, mirror, HDMI-A-1"
            ;;
        off)
            echo 'Turning Mirror off...'
            hyprctl keyword monitor "eDP-1, 1920x1080@60, auto, 1"
            hyprctl keyword monitor "HDMI-A-1, 1920x1080@60, auto, 1"
            ;;
        *)
            echo "Usage: mirror {on|off}"
            ;;
    esac
}

function start_droidcam(){
    sudo kill -9 1640 2634 31438
    sudo fuser -k /dev/video0
    sudo modprobe -r v4l2loopback
    sudo modprobe v4l2loopback devices=1 video_nr=0 card_label="DroidCam" exclusive_caps=1
    pkill droidcam
    droidcam
}

function mk() {
  vared -p 'Path: ' -c var
  mkdir "$var"
}

function to_audio() {
    if [ -z "$1" ]; then
        echo "Usage: to_audio <input_video_file>"
        return 1
    fi

    input="$1"
    filename=$(basename -- "$input")
    name="${filename%.*}"
    ffmpeg -i "$input" -vn -acodec copy "${name}_audio.aac"
}

